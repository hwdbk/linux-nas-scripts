#!/bin/bash
if (( $# == 0 )) ; then
	echo "usage: $(basename "$0") [-a] [-l] path [...]" >&2
	echo "       -a also descend into *-/ directories (normally filtered out)" >&2
	echo "output: prints a list of files with their Finder tags" >&2
	echo "        line format: path<tab>tag[,tag2...]" >&2
	echo "note:  $(basename "$0") lists the tags in the order they are stored in the filesystem, unlike the output of" >&2
	echo "       jdberry's Python tag script, which sorts the tags. preserving this order is important for the Finder" >&2
	echo "       label colours (i.e. showing Purple on top of Green or Green on top of Purple)." >&2
	exit 1
fi

if [[ $1 == -a ]] ; then all=y ; shift ; fi # also descend into *-/ directories (normally filtered out)

for n in "$@" ; do
	if [[ ! -e $n ]] ; then
		echo "$n: not a file or directory" >&2
		continue
	fi
	find_attr com.apple.metadata:_kMDItemUserTags "$n" | while read f ; do # filter only on files that have the _kMDItemUserTags metadata xattr
		# note: (nested) directories with tag(s) within directories with links (marked by directory-/ e.g. path/genres-/Drama, or path/genres-/Sets/James Bond)
		#       must not be filtered, only the files within those, i.e. skip files _within_ "Drama", "Sets" or "James Bond", not these directories themselves, which may have a useful tag.
		# note: this is equivalent to filtering the grep output through | grep -v -- '-/.*\.[^ ]' | sed -e 's#/@eaDir/#/#' -e 's#@SynoEAStream##', but that doesn't do the -all
		#       and is only marginally faster than the below (calling 'tag' is the bottleneck)
		if [[ -n $all || -d $f || ( -f $f && $f != *-/* ) ]] ; then # exclude files with tag(s) found within linked directories (directories whose name end with -)
			echo -n -e "$f\0"
		fi
	done | xargs -0 tag -lnG # default output (-lnG) is: name\ttag1,tag2...\n
done
#EOF
